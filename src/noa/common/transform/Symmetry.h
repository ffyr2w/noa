#pragma once

#include <string_view>
#include <algorithm> // std::copy

#include "noa/common/Definitions.h"
#include "noa/common/Types.h"
#include "noa/common/Exception.h"
#include "noa/common/string/Convert.h"

namespace noa::transform {
    /// Symmetry operator.
    /// \details This class can parse a string containing a symmetry symbol and converts this symbol
    ///          in a set of 3x3 rotation matrices that can then be applied to a 3D array to enforce
    ///          the desired symmetry. Supported symbols are CX, DX, O, I1 and I2, with X being a
    ///          non-zero positive number.
    /// \note The identity matrix is not generated, since performing an interpolation for the identity
    ///       is quite overkill when a copy of the input array is faster and more accurate.
    /// \note CX and DX symmetries can be applied to a 2D logical array. The 2x2 symmetry matrices can be
    ///       extracted from the 3x3 matrices generated by this class.
    class Symmetry {
    public:
        /// Symmetry symbol.
        struct Symbol {
            uint order; // O = 0, C|D = X, I1 = 1, I2 = 2
            char type; // C, D, O, I
        };

    private:
        // The class is not allocating data at construction. The matrices are allocated and set by the
        // getMatrices() method. This allows to copy the object without any heap allocation if the object
        // hasn't called getMatrices() before.
        std::unique_ptr<float33_t[]> m_rotm{}; // only used for C and D symmetries
        uint m_count{}; // number of symmetry matrices, ignoring the identity, to describe the symmetry
        Symbol m_symbol{};

        // Supported are CX, DX, O, I1, I2. X is a non-zero positive integer.
        // The string should be left trimmed.
        // This is not allocating nor setting the matrices.
        NOA_HOST void parse_(std::string_view symbol);

    public:
        /// Creates an empty instance. Use reset().
        constexpr Symmetry() = default;

        /// Parses the symmetry symbol. Throws if the symmetry isn't recognized.
        NOA_HOST explicit Symmetry(std::string_view symmetry) { parse_(symmetry); }

        /// Resets the current symmetry to a new symmetry. Throws if the symmetry symbol isn't recognized.
        NOA_HOST void reset(std::string_view symmetry) {
            parse_(symmetry);
            m_rotm.reset(nullptr);
        }

    public: // Access data
        /// Returns the symmetry matrices, ignoring the identity matrix, required to describe the symmetry.
        /// The number of matrices can be accessed at any time using getCount().
        NOA_HOST const float33_t* getMatrices();

        /// Returns the number of matrices returned by getMatrices().
        NOA_HOST [[nodiscard]] uint getCount() const { return m_count; }

        /// Returns the symbol of the current symmetry. \see Symmetry::Symbol.
        NOA_HOST [[nodiscard]] Symbol getSymbol() const { return m_symbol; }

        /// Formats the symmetry symbol to its string representation.
        NOA_HOST [[nodiscard]] std::string toString() const {
            if (m_symbol.order) // CX, DX, I1, I2
                return string::format("{}{}", m_symbol.type, m_symbol.order);
            else
                return {m_symbol.type}; // O
        }

    public: // Copy and move operations
        /// Copy constructor. Performs a deep copy of the data.
        NOA_HOST Symmetry(const Symmetry& to_copy)
                : m_count(to_copy.m_count), m_symbol(to_copy.m_symbol) {
            // The matrices might not be allocated yet.
            if (to_copy.m_rotm) {
                m_rotm = std::make_unique<float33_t[]>(m_count);
                std::copy(to_copy.m_rotm.get(), to_copy.m_rotm.get() + m_count, m_rotm.get());
            }
        }

        /// Copy assignment operator. Performs a deep copy of the data.
        NOA_HOST Symmetry& operator=(const Symmetry& to_copy) {
            if (this == &to_copy)
                return *this;

            m_count = to_copy.m_count;
            m_symbol = to_copy.m_symbol;

            // The matrices might not be allocated yet.
            if (to_copy.m_rotm) {
                m_rotm = std::make_unique<float33_t[]>(m_count); // deletes existing data
                std::copy(to_copy.m_rotm.get(), to_copy.m_rotm.get() + m_count, m_rotm.get());
            } else {
                m_rotm.reset(nullptr);
            }
            return *this;
        }

        // Shallow copies
        NOA_HOST Symmetry(Symmetry&& to_move) noexcept = default;
        NOA_HOST Symmetry& operator=(Symmetry&& to_move) noexcept = default;
    };

    NOA_IH std::ostream& operator<<(std::ostream& os, const Symmetry& s) {
        os << s.toString();
        return os;
    }
}
